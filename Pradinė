// v.pradinė
#include <iostream>         // Leidžia naudoti cin ir cout
#include <iomanip>          // Leidžia formatuoti išvestį
#include <vector>           // Leidžia įvesti vektorius
#include <string>           // Leidžia įvesti string tipo kintamuosius
#include <limits>           // Naudojama valyti įvesties srautą
#include <algorithm>        // Leidžia naudoti sort funkciją

using std::cout;            // Išvedimas
using std::cin;             // Įvedimas
using std::endl;            // Nauja eilutė
using std::string;          // String tipo kintamieji
using std::vector;          // Vektoriai
using std::setw;            // Išvedimo metu nurodo plotį
using std::left;            // Lygiavimas į kairę
using std::right;           // Lygiavimas į dešinę
using std::fixed;           // Fiksuotas kablelis
using std::setprecision;    // Nustato skaičių po kablelio skaičių
using std::sort;            // Rūšiavimas

// Aprašomas nuosavas duomenų tipas
struct Studentas {
    string vard;
    string pav;
    vector<int> paz;
    int egzas;
    float rez_vid, rez_med;
};

float sk_mediana(vector<int> paz);
Studentas ivesk();

// Pagrindinė programos funkcija
int main() {
    vector<Studentas> Grupe;
    int kiek;
    // Tikriname studentų skaičiaus įvedimą
    while (true) {
        cout<<"Kiek studentų yra grupėje? ";
        if (cin >> kiek && kiek > 0) {
            break; // teisingas įvedimas
        } else {
            cout<<"Klaida: studentų skaičius turi būti teigiamas skaičius! Įvesti dar kartą.\n";
            cin.clear(); // nuimam failbit
            cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // išvalom blogą įvestį
        }
    }
    for (int j=0; j<kiek; j++) {
        cout<<"Įveskite "<<j+1<<" studentą:\n";
        Grupe.push_back(ivesk());
    }
    cout << left << setw(15) << "Vardas"
     << "| " << setw(15) << "Pavardė"
     << "| " << right << setw(15) << "Galutinis (vid.)"
     << " | " << setw(15) << "Galutinis (med.)"
     << endl;
    cout << std::string(65, '-') << endl; // atskyrimo linija
    for (auto temp: Grupe)
        cout << left << setw(15) << temp.vard
         << "| " << setw(15) << temp.pav
         << "| " << right << setw(15) << fixed << setprecision(2) << temp.rez_vid
         << " | " << setw(15) << fixed << setprecision(2) << temp.rez_med
         << endl;
}

Studentas ivesk() {
    Studentas Laik;
    int sum=0, n, m;    
    cout<<"Įveskite studento vardą: "; cin>>Laik.vard;
    cout<<"Įveskite studento pavardę: "; cin>>Laik.pav;

    while (true) {
        cout<<"Kiek pažymių turi studentas? "; cin>>n;
        if (n > 0) {
            break;
        } else {
            cout<<"Klaida: pažymių kiekis turi būti teigiamas skaičius! Įvesti dar kartą.\n";
            cin.clear(); // išvalom klaidos būseną
            cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // išvalom blogą įvestį
        }
    }

    for (int i=0; i<n; i++) {
        do {
            cout<<"Įveskite "<<i+1<<" pažymį iš "<<n<<" : "; cin>>m;
            if (m < 1 || m > 10) {
                cout<<"Klaida: pažymys turi būti nuo 1 iki 10! Pažymį įvesti dar kartą.\n";
                // Valome įvesties srautą, kad išvengtume begalinio ciklo, jei įvedamas ne skaičius
                cin.clear();
                cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            }
        } while (m < 1 || m > 10);  // kartojame, kol įvedama teisingai
        Laik.paz.push_back(m);
        sum+=m;
    }

    do {
        cout<<"Įveskite egzamino rezultatą (1-10): ";
        cin>>Laik.egzas;
        if (Laik.egzas < 1 || Laik.egzas > 10) {
            cout<<"Klaida: egzamino įvertinimas turi būti nuo 1 iki 10! Įvertinimą įvesti dar kartą.\n";
            // Valome įvesties srautą, kad išvengtume begalinio ciklo, jei įvedamas ne skaičius
            cin.clear();
            cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
    } while (Laik.egzas < 1 || Laik.egzas > 10);

    float mediana = sk_mediana(Laik.paz);

    Laik.rez_vid = Laik.egzas*0.6 + double(sum)/double(Laik.paz.size())*0.4;
    Laik.rez_med = Laik.egzas*0.6 + mediana*0.4;
    return Laik;
}

float sk_mediana(vector<int> paz) {
    sort(paz.begin(), paz.end());
    int n = paz.size();
    if (n % 2 == 0) {
        return (paz[n/2 - 1] + paz[n/2]) / 2.0;
    } else {
        return paz[n/2];
    }
}
